html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Cell Membrane Animation</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  background-color: #fffcf5;
  font-family: 'Patrick Hand', cursive;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
#container {
  width: 1920px;
  height: 1080px;
  position: relative;
}
canvas {
  background-color: #fffcf5;
  display: block;
}
#subtitles {
  position: absolute;
  top: 900px;
  left: 50%;
  transform: translateX(-50%);
  width: 100%;
  text-align: center;
  font-size: 32px;
  color: #333;
}
#controls {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 10px;
  text-align: center;
}
#timeline {
  width: 60%;
  height: 10px;
  background-color: #ccc;
  cursor: pointer;
  display: inline-block;
  margin-right: 10px;
}
#timeline-progress {
  height: 10px;
  background-color: #337ab7;
  width: 0;
}
#timecode {
  display: inline-block;
  width: 80px;
}
#duration-slider {
  width: 100px;
}
@import url('https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap');
</style>
<link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
</head>
<body>
<div id="container">
  <canvas id="animationCanvas" width="1920" height="1080"></canvas>
  <div id="subtitles"></div>
  <div id="controls">
    <button id="playPauseBtn">Play</button>
    <span id="timecode">00:00 / 00:00</span>
    <div id="timeline">
      <div id="timeline-progress"></div>
    </div>
    <label for="duration-slider">Duration (s):</label>
    <input type="range" id="duration-slider" min="30" max="180" value="60">
    <button id="exportBtn">Export Video</button>
  </div>
</div>
<script>
const canvas = document.getElementById('animationCanvas');
const ctx = canvas.getContext('2d');
const subtitlesDiv = document.getElementById('subtitles');
const playPauseBtn = document.getElementById('playPauseBtn');
const timeline = document.getElementById('timeline');
const timelineProgress = document.getElementById('timeline-progress');
const timecodeDisplay = document.getElementById('timecode');
const durationSlider = document.getElementById('duration-slider');
const exportBtn = document.getElementById('exportBtn');

let animationFrameId;
let startTime;
let currentTime = 0;
let duration = parseInt(durationSlider.value);
let isPlaying = false;
let mediaRecorder;
let recordedChunks = [];

const narration = [
  { time: 0, text: "Imagine a breathtaking stained-glass window, each pane a cell, bustling with life." },
  { time: 5, text: "This artistry of nature starts with something even more fundamental: the cell membrane, the cell's own masterpiece." },
  { time: 10, text: "It's like a living canvas, a fluid mosaic made of tiny, dancing molecules called phospholipids, forming a double-layered barrier." },
  { time: 15, text: "Embedded within this layer are proteins, like sculptures on a building's facade, each with a unique function." },
  { time: 20, text: "These proteins act as gatekeepers, carefully controlling which molecules, like ions and nutrients, can enter and exit the cell." },
  { time: 25, text: "This selective permeability ensures the cell's internal environment remains stable and protected." },
  { time: 30, text: "The cell membrane is not just a barrier, itâ€™s a dynamic interface, facilitating connections, signaling other cells, and providing a surface for internal cellular structures to anchor." },
  { time: 35, text: "So, next time you admire a piece of art, remember the cell membrane, a hidden masterpiece of structure, function, and selective artistry." },
  { time: 40, text: "Let its brilliant balance inspire your own creativity." },
];

function roughLine(x1, y1, x2, y2, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x1 + Math.random() * 3, y1 + Math.random() * 3);
  ctx.lineTo(x2 + Math.random() * 3, y2 + Math.random() * 3);
  ctx.stroke();
}

function drawStickFigure(x, y, pose, scale, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 5;

  switch (pose) {
    case 'idle':
      // Head
      ctx.beginPath();
      ctx.arc(x, y - 50 * scale, 20 * scale, 0, 2 * Math.PI);
      ctx.stroke();

      // Body
      roughLine(x, y - 30 * scale, x, y + 50 * scale, color);

      // Arms
      roughLine(x, y, x - 40 * scale, y + 20 * scale, color);
      roughLine(x, y, x + 40 * scale, y + 20 * scale, color);

      // Legs
      roughLine(x, y + 50 * scale, x - 30 * scale, y + 100 * scale, color);
      roughLine(x, y + 50 * scale, x + 30 * scale, y + 100 * scale, color);
      break;
    case 'thinking':
      // Head
      ctx.beginPath();
      ctx.arc(x, y - 50 * scale, 20 * scale, 0, 2 * Math.PI);
      ctx.stroke();

      // Body
      roughLine(x, y - 30 * scale, x, y + 50 * scale, color);

      // Arms (folded)
      roughLine(x, y, x - 20 * scale, y + 10 * scale, color);
      roughLine(x - 20 * scale, y + 10 * scale, x + 20 * scale, y + 10 * scale, color);
      roughLine(x, y, x + 20 * scale, y + 10 * scale, color);

      // Legs
      roughLine(x, y + 50 * scale, x - 30 * scale, y + 100 * scale, color);
      roughLine(x, y + 50 * scale, x + 30 * scale, y + 100 * scale, color);
      break;
    case 'running':
      // Head
      ctx.beginPath();
      ctx.arc(x, y - 50 * scale, 20 * scale, 0, 2 * Math.PI);
      ctx.stroke();

      // Body (leaning forward)
      roughLine(x, y - 30 * scale, x, y + 50 * scale, color);

      // Arms (swinging)
      roughLine(x, y, x - 50 * scale, y - 10 * scale, color);
      roughLine(x, y, x + 50 * scale, y + 30 * scale, color);

      // Legs (in motion)
      roughLine(x, y + 50 * scale, x - 40 * scale, y + 80 * scale, color);
      roughLine(x, y + 50 * scale, x + 40 * scale, y + 120 * scale, color);
      break;
  }
}

function renderScene(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.font = '48px "Patrick Hand"';
  ctx.fillStyle = '#333';

  if (time >= 0 && time < 5) {
    // Scene 1
    ctx.fillStyle = '#a8d0e6';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#333';
    ctx.fillText("Stained-Glass Cell View", 800, 100);
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const size = Math.random() * 50 + 50;
      const color = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.7)`;
      ctx.fillStyle = color;
      ctx.fillRect(x, y, size, size);
    }
  } else if (time >= 5 && time < 10) {
    // Scene 2
    ctx.fillStyle = '#fbc740';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#333';
    ctx.fillText("Zooming to Cell Membrane", 750, 100);

    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, 2 * Math.PI);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 5;
    ctx.stroke();

  } else if (time >= 10 && time < 15) {
    // Scene 3
    ctx.fillStyle = '#37474f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.fillText("Fluid Mosaic Model", 800, 100);

    // Draw Phospholipids
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fill();
      ctx.fillRect(x - 5, y + 10, 10, 20); // Tail
    }
  } else if (time >= 15 && time < 20) {
    // Scene 4
    ctx.fillStyle = '#76b852';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#333';
    ctx.fillText("Membrane Proteins", 800, 100);

    // Draw Integral Protein
    ctx.fillStyle = '#f9d423';
    ctx.fillRect(canvas.width / 2 - 50, canvas.height / 2 - 100, 100, 200);

    // Draw Peripheral Protein
    ctx.fillStyle = '#cc2e5d';
    ctx.beginPath();
    ctx.arc(canvas.width / 2 + 100, canvas.height / 2, 30, 0, 2 * Math.PI);
    ctx.fill();

  } else if (time >= 20 && time < 25) {
    // Scene 5
    ctx.fillStyle = '#f44336';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.fillText("Selective Transport", 800, 100);

    // Draw Ion
    ctx.fillStyle = '#03a9f4';
    ctx.beginPath();
    ctx.arc(200, canvas.height / 2, 20, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText("+", 190, canvas.height / 2 + 10);

     // Draw Ion moving through the protein
    let ionX = 200 + (time - 20) * 100;
    if(ionX > 1720) ionX = 200;
    ctx.fillStyle = '#03a9f4';
    ctx.beginPath();
    ctx.arc(ionX, canvas.height / 2, 20, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText("+", ionX - 10, canvas.height / 2 + 10);

  } else if (time >= 25 && time < 30) {
    // Scene 6
    ctx.fillStyle = '#4caf50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#333';
    ctx.fillText("Stable Internal Environment", 750, 100);
    drawStickFigure(canvas.width / 2, canvas.height/2 + 100, 'thinking', 2, '#333');

  } else if (time >= 30 && time < 35) {
    // Scene 7
        ctx.fillStyle = '#9c27b0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.fillText("Cell Signaling", 800, 100);

        // Two cells interacting
        ctx.beginPath();
        ctx.arc(canvas.width / 4, canvas.height / 2, 100, 0, 2 * Math.PI);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(canvas.width * 3 / 4, canvas.height / 2, 100, 0, 2 * Math.PI);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.stroke();

        // Draw signaling molecules
        for (let i = 0; i < 10; i++) {
          const x = canvas.width / 4 + Math.random() * canvas.width / 2;
          const y = canvas.height / 2 + Math.random() * 50 - 25;
          ctx.fillStyle = 'yellow';
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2 * Math.PI);
          ctx.fill();
        }

  } else if (time >= 35 && time < 40) {
        // Scene 8
        ctx.fillStyle = '#ff9800';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#333';
        ctx.fillText("Hidden Masterpiece", 800, 100);
  } else if (time >= 40 && time < 45) {
        // Scene 9
        ctx.fillStyle = '#607d8b';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.fillText("Inspire Creativity", 800, 100);
        drawStickFigure(canvas.width / 2, canvas.height/2 + 100, 'idle', 2, '#fff');
  }
}

function updateSubtitles(time) {
  let subtitleText = '';
  for (let i = 0; i < narration.length; i++) {
    if (time >= narration[i].time && time < (narration[i].time + 5)) {
      subtitleText = narration[i].text;
      break;
    }
  }
  subtitlesDiv.textContent = subtitleText;
}

function updateTimeline(time) {
  const progress = (time / duration) * 100;
  timelineProgress.style.width = `${progress}%`;
}

function formatTime(seconds) {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  const formattedMinutes = String(minutes).padStart(2, '0');
  const formattedSeconds = String(remainingSeconds).padStart(2, '0');
  return `${formattedMinutes}:${formattedSeconds}`;
}

function updateTimecode(time) {
  timecodeDisplay.textContent = `${formatTime(time)} / ${formatTime(duration)}`;
}

function animationLoop(timestamp) {
  if (!startTime) startTime = timestamp;
  const dt = (timestamp - startTime) / 1000;
  startTime = timestamp;
  currentTime += dt;

  if (currentTime > duration) {
    currentTime = 0;
    isPlaying = false;
    playPauseBtn.textContent = 'Play';
  }

  renderScene(currentTime);
  updateSubtitles(currentTime);
  updateTimeline(currentTime);
  updateTimecode(currentTime);

  animationFrameId = requestAnimationFrame(animationLoop);
}

function playPause() {
  if (isPlaying) {
    isPlaying = false;
    cancelAnimationFrame(animationFrameId);
    playPauseBtn.textContent = 'Play';
  } else {
    isPlaying = true;
    startTime = null; // Reset start time for smooth looping
    animationLoop();
    playPauseBtn.textContent = 'Pause';
  }
}

function seek(event) {
  const rect = timeline.getBoundingClientRect();
  const clickPosition = event.clientX - rect.left;
  const seekTime = (clickPosition / rect.width) * duration;
  currentTime = seekTime;
  renderScene(currentTime);
  updateSubtitles(currentTime);
  updateTimeline(currentTime);
  updateTimecode(currentTime);
}

function handleDurationChange() {
  duration = parseInt(durationSlider.value);
  updateTimecode(currentTime);
}

function startRecording() {
  recordedChunks = [];
  const stream = canvas.captureStream(24);
  mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

  mediaRecorder.ondataavailable = event => {
    if (event.data.size > 0) {
      recordedChunks.push(event.data);
    }
  };

  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'animation.webm';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    exportBtn.textContent = 'Export Video';
  };

  mediaRecorder.start();
  exportBtn.textContent = 'Stop Export';
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
}

function toggleRecording() {
  if (exportBtn.textContent === 'Export Video') {
    startRecording();
  } else {
    stopRecording();
  }
}

playPauseBtn.addEventListener('click', playPause);
timeline.addEventListener('click', seek);
durationSlider.addEventListener('input', handleDurationChange);
exportBtn.addEventListener('click', toggleRecording);

// Initial setup
updateTimecode(0);
renderScene(0);
updateSubtitles(0);
</script>
</body>
</html>