html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cell Membrane: The Kitchen of Life</title>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #fffcf5;
            font-family: 'Patrick Hand', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #container {
            width: 1920px;
            height: 1080px;
            position: relative;
        }

        canvas {
            background-color: #fffcf5;
            display: block;
        }

        #subtitles {
            position: absolute;
            top: 900px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
            font-size: 32px;
            color: #333;
        }

        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 252, 245, 0.8);
            padding: 10px;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        #timeline {
            width: 400px;
            height: 10px;
            background-color: #ddd;
            cursor: pointer;
        }

        #timeline-progress {
            height: 10px;
            background-color: #aaa;
            width: 0;
        }

        input[type=range] {
          width: 150px;
        }

        button {
            font-family: 'Patrick Hand', sans-serif;
            padding: 5px 10px;
            font-size: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="animationCanvas" width="1920" height="1080"></canvas>
        <div id="subtitles"></div>
        <div id="controls">
            <button id="playPauseBtn">Play</button>
            <div id="timeline">
                <div id="timeline-progress"></div>
            </div>
            <span id="timecode">00:00 / 01:00</span>
            <label for="duration">Duration (s):</label>
            <input type="range" id="duration" min="30" max="180" value="60">
            <button id="exportBtn">Export Video</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const subtitlesDiv = document.getElementById('subtitles');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const timeline = document.getElementById('timeline');
        const timelineProgress = document.getElementById('timeline-progress');
        const timecodeDisplay = document.getElementById('timecode');
        const durationSlider = document.getElementById('duration');
        const exportBtn = document.getElementById('exportBtn');

        let animationFrameId;
        let startTime;
        let paused = false;
        let duration = 60; // Default duration
        let recordedChunks = [];
        let mediaRecorder;
        let isRecording = false;

        // Narration
        const narration = [
           { time: 0, text: "Imagine your cell is like a bustling kitchen, always cooking up something amazing! But every kitchen needs walls to protect its ingredients and control what comes in and out." },
            { time: 5, text: "That's exactly what the cell membrane does â€“ it's the cell's master chef, deciding which flavors and ingredients can enter and exit." },
            { time: 10, text: "It's built like a delicious, double-layered pastry called a lipid bilayer, made of fatty molecules called phospholipids, creating a flexible and dynamic wall." },
            { time: 15, text: "Embedded within this pastry are protein chefs, working like kitchen appliances to help transport key ingredients and communicate with the outside world." },
            { time: 20, text: "This membrane isn't just a simple wall, it's a selectively permeable gateway, carefully choosing which molecules can pass through, like a meticulous sous-chef inspecting every item." },
            { time: 25, text: "It also helps cells stick together to form complex tissues, like carefully arranging ingredients on a beautifully plated dish, and even helps conduct electrical signals, like sparking a fire for the perfect sear." },
            { time: 30, text: "Think of the cell membrane as the ultimate gatekeeper of the cell kitchen, carefully controlling the flow of traffic to maintain perfect order and keep the amazing culinary show inside running smoothly!" },
            { time: 40, text: "Just like the best dishes rely on careful ingredient selection, a healthy cell relies on a functional membrane." },
            { time: 50, text: "So, the next time you're whipping up a masterpiece, remember the incredible cell membrane and its vital role in keeping the kitchen of life cooking!" }
        ];

        // Utility functions
        function roughLine(x1, y1, x2, y2, color) {
            ctx.beginPath();
            ctx.moveTo(x1 + Math.random() * 3, y1 + Math.random() * 3);
            ctx.lineTo(x2 + Math.random() * 3, y2 + Math.random() * 3);
            ctx.strokeStyle = color;
            ctx.stroke();
        }

        function drawStickFigure(x, y, pose = 'idle', scale = 1, color = 'black') {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            // Head
            ctx.beginPath();
            ctx.arc(x, y - 40 * scale, 20 * scale, 0, 2 * Math.PI);
            ctx.stroke();

            // Body
            roughLine(x, y - 20 * scale, x, y + 40 * scale, color);

            // Arms
            if (pose === 'running') {
                roughLine(x, y, x - 30 * scale, y + 10 * scale, color);
                roughLine(x, y, x + 30 * scale, y - 10 * scale, color);
            } else if (pose === 'thinking') {
                 roughLine(x, y, x - 30 * scale, y - 20 * scale, color);
                roughLine(x, y, x + 30 * scale, y - 20 * scale, color);

            }
            else {
                roughLine(x, y, x - 30 * scale, y, color);
                roughLine(x, y, x + 30 * scale, y, color);
            }


            // Legs
            if (pose === 'running') {
                roughLine(x, y + 40 * scale, x - 20 * scale, y + 70 * scale, color);
                roughLine(x, y + 40 * scale, x + 20 * scale, y + 50 * scale, color);
            } else {
                roughLine(x, y + 40 * scale, x - 20 * scale, y + 70 * scale, color);
                roughLine(x, y + 40 * scale, x + 20 * scale, y + 70 * scale, color);
            }
        }

        // Animation loop
        let currentTime = 0;
        let dt = 0;
        let lastTime = 0;

        function renderScene(timestamp) {
            dt = (timestamp - lastTime) / 1000;
            dt = Math.min(dt, 0.1);
            lastTime = timestamp;

            if (!startTime) startTime = timestamp;
            const elapsedTime = (timestamp - startTime) / 1000;
            currentTime = elapsedTime % duration;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Scene logic
            if (currentTime >= 0 && currentTime < 5) {
                // Kitchen scene
                ctx.fillStyle = '#f2d7b0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("A Cell's Busy Kitchen", 100, 100);
                 drawStickFigure(200, 300, 'idle', 3, '#333');
                 drawStickFigure(500, 300, 'running', 3, '#333');


            } else if (currentTime >= 5 && currentTime < 10) {
                 ctx.fillStyle = '#9dd0ed';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("The Master Chef Membrane", 100, 100);
                 drawStickFigure(500, 300, 'thinking', 3, '#333');
                  ctx.beginPath();
                  ctx.arc(1500, 300, 100, 0, 2 * Math.PI);
                  ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                  ctx.fill();
                  ctx.stroke();

            } else if (currentTime >= 10 && currentTime < 15) {
                // Lipid bilayer close-up
                 ctx.fillStyle = '#ffc0cb';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("Double Layered Pastry", 100, 100);

                for(let i = 100; i < 1800; i+= 100){
                   ctx.beginPath();
                   ctx.arc(i, 300, 20, 0, Math.PI, true);
                   ctx.fillStyle = 'red';
                   ctx.fill();
                   ctx.stroke();
                   roughLine(i, 300, i, 400, 'orange');
                }

                 for(let i = 100; i < 1800; i+= 100){
                   ctx.beginPath();
                   ctx.arc(i, 500, 20, 0, Math.PI, false);
                   ctx.fillStyle = 'red';
                   ctx.fill();
                   ctx.stroke();
                    roughLine(i, 500, i, 400, 'orange');
                }


            } else if (currentTime >= 15 && currentTime < 20) {
                // Protein chefs
                 ctx.fillStyle = '#a0d6b4';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("Protein Chefs at Work", 100, 100);

                // Draw a rectangle representing a protein
                ctx.fillStyle = 'blue';
                ctx.fillRect(500, 300, 100, 200);

                // Simulate molecules passing through (simple lines)
                ctx.strokeStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(300, 350);
                ctx.lineTo(500, 350);
                ctx.stroke();

                ctx.strokeStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(600, 450);
                ctx.lineTo(800, 450);
                ctx.stroke();



            } else if (currentTime >= 20 && currentTime < 25) {
                // Selectively permeable
                ctx.fillStyle = '#f0e68c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("Selective Permeability", 100, 100);

                  ctx.fillStyle = 'green';
                  ctx.fillRect(400, 300, 50, 50);
                  ctx.fillStyle = 'red';
                  ctx.fillRect(400, 400, 50, 50);


                  ctx.strokeStyle = 'green';
                  ctx.beginPath();
                  ctx.moveTo(450, 325);
                  ctx.lineTo(600, 325);
                  ctx.stroke();

                ctx.strokeStyle = 'red';
                  ctx.beginPath();
                  ctx.moveTo(450, 425);
                  ctx.lineTo(600, 425);
                  ctx.stroke();

            } else if (currentTime >= 25 && currentTime < 30) {
                // Cell adhesion and signaling
                ctx.fillStyle = '#dda0dd';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("Cell Adhesion and Signaling", 100, 100);
                ctx.beginPath();
                ctx.arc(500, 500, 50, 0, 2 * Math.PI);
                ctx.fillStyle = '#333';
                ctx.fill();
                ctx.stroke();

                 ctx.beginPath();
                ctx.arc(700, 500, 50, 0, 2 * Math.PI);
                ctx.fillStyle = '#333';
                ctx.fill();
                ctx.stroke();


            } else if (currentTime >= 30 && currentTime < 40) {
                  ctx.fillStyle = '#fff2cc';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("The Ultimate Gatekeeper", 100, 100);
                 drawStickFigure(700, 300, 'thinking', 3, '#333');
            }
             else if (currentTime >= 40 && currentTime < 50) {
                  ctx.fillStyle = '#fff2cc';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("Healthy Cell, Healthy Membrane", 100, 100);
                 drawStickFigure(700, 300, 'idle', 3, '#333');
            }

               else if (currentTime >= 50 && currentTime < 60) {
                  ctx.fillStyle = '#fff2cc';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6b4226';
                ctx.font = '60px Patrick Hand';
                ctx.fillText("The Incredible Membrane", 100, 100);
                 drawStickFigure(700, 300, 'running', 3, '#333');
            }



            // Subtitle display
            let currentSubtitle = narration.find(subtitle => currentTime >= subtitle.time);
            subtitlesDiv.textContent = currentSubtitle ? currentSubtitle.text : '';

            // Timeline update
            const progress = (currentTime / duration) * 100;
            timelineProgress.style.width = `${progress}%`;

            // Timecode update
            const currentMinutes = Math.floor(currentTime / 60).toString().padStart(2, '0');
            const currentSeconds = Math.floor(currentTime % 60).toString().padStart(2, '0');
            const totalMinutes = Math.floor(duration / 60).toString().padStart(2, '0');
            const totalSeconds = Math.floor(duration % 60).toString().padStart(2, '0');
            timecodeDisplay.textContent = `${currentMinutes}:${currentSeconds} / ${totalMinutes}:${totalSeconds}`;

            if (!paused) {
                animationFrameId = requestAnimationFrame(renderScene);
            }
        }

        // Event listeners
        playPauseBtn.addEventListener('click', () => {
            paused = !paused;
            playPauseBtn.textContent = paused ? 'Play' : 'Pause';
            if (!paused) {
                startTime = null;
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(renderScene);
            } else {
                cancelAnimationFrame(animationFrameId);
            }
        });

        timeline.addEventListener('click', (e) => {
            const rect = timeline.getBoundingClientRect();
            const clickPosition = e.clientX - rect.left;
            const seekTime = (clickPosition / rect.width) * duration;
            currentTime = seekTime;
            startTime = performance.now() - (currentTime * 1000); // Adjust start time
            renderScene(performance.now());
        });

        durationSlider.addEventListener('input', () => {
            duration = parseInt(durationSlider.value);
            startTime = null; // Reset animation
            currentTime = 0;
            renderScene(performance.now());
        });

        exportBtn.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        function startRecording() {
            recordedChunks = [];
            const stream = canvas.captureStream(24);
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                downloadVideo();
            };

            mediaRecorder.start();
            isRecording = true;
            exportBtn.textContent = 'Stop Export';
        }

        function stopRecording() {
            mediaRecorder.stop();
            isRecording = false;
            exportBtn.textContent = 'Export Video';
        }

        function downloadVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cell_membrane_animation.webm';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initial call
        animationFrameId = requestAnimationFrame(renderScene);
    </script>
</body>
</html>